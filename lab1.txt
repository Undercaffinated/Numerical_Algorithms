Nathan Howell
Lab 1 : Jan 24, 2026
=====================================================

  1. In series A, x = -0.9. In series B, x = 0.9 / 2.9 (~.31).

  2. At a glance, series A, but I assume this is a trick question, so series B.

=====================================================

  With 5 terms, these are the results:
  Series A - Value: 0.6920729999999999, Error: -0.050219113827605244
  Series B - Value: 0.641853376926429, Error: 0.0000005092459657296544

=====================================================

  Series B is far more efficient than series A. My assumption is that this is due to Series B's initial term being a much better approximate of ln(1.9) than series A's. I would assume then that by having more precise terms, defined by a more adequate term definition, we arrive at a higher level of precision much faster.

=====================================================

Code: Written in Rust. Can be found on Github at https://github.com/Undercaffinated/Numerical_Algorithms/tree/main

// main.rs -----------------------------------------------

mod math;
use math::*;

fn main() {
    // Allocate space for the taylor series terms' values.
    let mut series_a_terms: Vec<f64> = Vec::new();
    let mut series_b_terms: Vec<f64> = Vec::new();

    // Determine the minimum number of terms required to reach err < 1e-10 for both series.
    let required_terms_a: i32 = get_required_terms(&mut series_a_terms, gen_series_a_term, SERIES_A_SCALAR);
    let retuired_terms_b: i32 = get_required_terms(&mut series_b_terms, gen_series_b_term, SERIES_B_SCALAR);

    println!("To reach err < 1e-10...");
    println!("Series A took {} terms.", required_terms_a);
    println!("Series B took {} terms.", retuired_terms_b);
    println!();

    // From here on, we will be working with a user-specified number of terms, n.
    let n: i32 = get_n();
    println!();

    // Clears the vectors without freeing memory so they can be re-used in the next step.
    series_a_terms.clear();
    series_b_terms.clear();

    // Calculate the terms
    for i in 1..=n {
        series_a_terms.push(gen_series_a_term(i));
        series_b_terms.push(gen_series_b_term(i));
    }

    // Calculate the sums
    let series_a_sum: f64 = sum_vector_elements(&series_a_terms);
    let series_b_sum: f64 = sum_vector_elements(&series_b_terms);

    // Apply scalars
    let series_a_sum: f64 = -series_a_sum;
    let series_b_sum: f64 = series_b_sum * 2.0;

    // Calculate the error
    let series_a_error: f64 = 1.9_f64.ln() - series_a_sum;
    let series_b_error: f64 = 1.9_f64.ln() - series_b_sum;

    println!("With {} terms, these are the results:", n);
    println!("Series A - Value: {}, Error: {}" , series_a_sum, series_a_error);
    println!("Series B - Value: {}, Error: {}" , series_b_sum, series_b_error);
    println!();
}


/// Gets an integer n from the user. Will panic if the input cannot be parsed.
fn get_n() -> i32 {
    println!("n: ");
    let mut input: String = String::new();
    let _ = std::io::stdin().read_line(&mut input);
    input.trim().parse().unwrap()
}



// math.rs --------------------------------------------------------

// These values are pulled from eariler in the homework.
const SERIES_A_X: f64 = -0.9;
const SERIES_B_X: f64 = 0.9 / 2.9;

// Given by the approximation functions on the homework.
pub const SERIES_A_SCALAR: f64 = -1.0;
pub const SERIES_B_SCALAR: f64 = 2.0;


/// Finds the sum of all elements in a vector.
pub fn sum_vector_elements(vec: &Vec<f64>) -> f64 {
    let mut sum: f64 = 0.0;

    for each in vec {
        sum += each;
    }

    sum
}

/// Returns the number of terms required to calculate to a desired precision.
pub fn get_required_terms(series: &mut Vec<f64>, method: fn(i32) -> f64, scalar: f64) -> i32 {
    let ln_one_point_nine = 1.9_f64.ln();

    series.clear();

    // Use a loop to try increasingly many terms to find when error < 1e-10
    loop {
        series.push(method((series.len() + 1) as i32));

        if (ln_one_point_nine - scalar * sum_vector_elements(&series)).abs() < 1e-10 {
            break;
        }
    }

    return series.len() as i32;
}

/// Calculates the value of the nth term of Series A
pub fn gen_series_a_term(term_degree: i32) -> f64 {
    SERIES_A_X.powi(term_degree) / term_degree as f64
}

/// Calculates the value of the nth term of Series B
pub fn gen_series_b_term(term_degree: i32) -> f64 {
    SERIES_B_X.powi(2*term_degree - 1) / (2*term_degree - 1) as f64
}

